"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doPatternsMatchUrl = exports.decodeBase64Params = void 0;
const micromatch_1 = require("micromatch");
/**
 * Support for Gatsby-style base64-encoded URLs
 */
function decodeBase64Params(path) {
    const [url, transform] = path.split('/');
    if (!url || !transform) {
        return {
            error: 'Bad Request'
        };
    }
    const id = Buffer.from(url, 'base64').toString('utf8');
    // Strip the extension
    const transforms = Buffer.from(transform.split('.')[0], 'base64').toString('utf8');
    if (!id || !transforms) {
        return {
            error: 'Bad Request'
        };
    }
    const params = new URLSearchParams(transforms);
    //  [ipx modifier name, gatsby modifier name]
    const props = [
        ['f', 'fm'],
        ['crop', 'pos'],
        ['q', 'q']
    ];
    const modifiers = [];
    const w = params.get('w');
    const h = params.get('h');
    if (w && h) {
        modifiers.push(`s_${w}x${h}`);
    }
    else {
        props.push(['w', 'w'], ['h', 'h']);
    }
    for (const [modifier, prop] of props) {
        let value = params.get(prop);
        if (value) {
            if (prop === 'pos') {
                value = value.replace(',', ' ');
            }
            modifiers.push(`${modifier}_${value}`);
        }
    }
    return { id, modifiers: modifiers.join(',') };
}
exports.decodeBase64Params = decodeBase64Params;
function doPatternsMatchUrl(remotePattern, parsedUrl) {
    if (remotePattern.protocol) {
        // parsedUrl.protocol contains the : after the http/https, remotePattern does not
        if (remotePattern.protocol !== parsedUrl.protocol.slice(0, -1)) {
            return false;
        }
    }
    // ufo's ParsedURL doesn't separate out ports from hostname, so this formats next's RemotePattern to match that
    const hostAndPort = remotePattern.port ? `${remotePattern.hostname}:${remotePattern.port}` : remotePattern.hostname;
    if (!(0, micromatch_1.makeRe)(hostAndPort).test(parsedUrl.host)) {
        return false;
    }
    if (remotePattern.pathname) {
        if (!(0, micromatch_1.makeRe)(remotePattern.pathname).test(parsedUrl.pathname)) {
            return false;
        }
    }
    return true;
}
exports.doPatternsMatchUrl = doPatternsMatchUrl;
