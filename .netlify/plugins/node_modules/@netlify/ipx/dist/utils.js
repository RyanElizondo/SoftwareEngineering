"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Lock_locked, _Lock_ee;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Lock = exports.doPatternsMatchUrl = exports.decodeBase64Params = void 0;
const events_1 = require("events");
const micromatch_1 = require("micromatch");
/**
 * Support for Gatsby-style base64-encoded URLs
 */
function decodeBase64Params(path) {
    const [url, transform] = path.split('/');
    if (!url || !transform) {
        return {
            error: 'Bad Request'
        };
    }
    const id = Buffer.from(url, 'base64').toString('utf8');
    // Strip the extension
    const transforms = Buffer.from(transform.split('.')[0], 'base64').toString('utf8');
    if (!id || !transforms) {
        return {
            error: 'Bad Request'
        };
    }
    const params = new URLSearchParams(transforms);
    //  [ipx modifier name, gatsby modifier name]
    const props = [
        ['f', 'fm'],
        ['crop', 'pos'],
        ['q', 'q']
    ];
    const modifiers = [];
    const w = params.get('w');
    const h = params.get('h');
    if (w && h) {
        modifiers.push(`s_${w}x${h}`);
    }
    else {
        props.push(['w', 'w'], ['h', 'h']);
    }
    for (const [modifier, prop] of props) {
        let value = params.get(prop);
        if (value) {
            if (prop === 'pos') {
                value = value.replace(',', ' ');
            }
            modifiers.push(`${modifier}_${value}`);
        }
    }
    return { id, modifiers: modifiers.join(',') };
}
exports.decodeBase64Params = decodeBase64Params;
function doPatternsMatchUrl(remotePattern, parsedUrl) {
    if (remotePattern.protocol) {
        // parsedUrl.protocol contains the : after the http/https, remotePattern does not
        if (remotePattern.protocol !== parsedUrl.protocol.slice(0, -1)) {
            return false;
        }
    }
    // ufo's ParsedURL doesn't separate out ports from hostname, so this formats next's RemotePattern to match that
    const hostAndPort = remotePattern.port ? `${remotePattern.hostname}:${remotePattern.port}` : remotePattern.hostname;
    if (!(0, micromatch_1.makeRe)(hostAndPort).test(parsedUrl.host)) {
        return false;
    }
    if (remotePattern.pathname) {
        if (!(0, micromatch_1.makeRe)(remotePattern.pathname).test(parsedUrl.pathname)) {
            return false;
        }
    }
    return true;
}
exports.doPatternsMatchUrl = doPatternsMatchUrl;
class Lock {
    constructor() {
        _Lock_locked.set(this, false);
        _Lock_ee.set(this, new events_1.EventEmitter());
    }
    acquire() {
        return new Promise((resolve) => {
            // If nobody has the lock, take it and resolve immediately
            if (!__classPrivateFieldGet(this, _Lock_locked, "f")) {
                // Safe because JS doesn't interrupt you on synchronous operations,
                // so no need for compare-and-swap or anything like that.
                __classPrivateFieldSet(this, _Lock_locked, true, "f");
                return resolve();
            }
            // Otherwise, wait until somebody releases the lock and try again
            const tryAcquire = () => {
                if (!__classPrivateFieldGet(this, _Lock_locked, "f")) {
                    __classPrivateFieldSet(this, _Lock_locked, true, "f");
                    __classPrivateFieldGet(this, _Lock_ee, "f").removeListener('release', tryAcquire);
                    return resolve();
                }
            };
            __classPrivateFieldGet(this, _Lock_ee, "f").on('release', tryAcquire);
        });
    }
    release() {
        // Release the lock immediately
        __classPrivateFieldSet(this, _Lock_locked, false, "f");
        setImmediate(() => __classPrivateFieldGet(this, _Lock_ee, "f").emit('release'));
    }
}
exports.Lock = Lock;
_Lock_locked = new WeakMap(), _Lock_ee = new WeakMap();
