"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIPXHandler = void 0;
const path_1 = require("path");
const os_1 = require("os");
const ipx_1 = require("ipx");
const functions_1 = require("@netlify/functions");
const ufo_1 = require("ufo");
const etag_1 = __importDefault(require("etag"));
const http_1 = require("./http");
const utils_1 = require("./utils");
const SUBREQUEST_HEADER = 'x-ipx-subrequest';
const plainText = {
    'Content-Type': 'text/plain'
};
function createIPXHandler({ cacheDir = (0, path_1.join)((0, os_1.tmpdir)(), 'ipx-cache'), basePath = '/_ipx/', propsEncoding, bypassDomainCheck, remotePatterns, responseHeaders, localPrefix, ...opts } = {}) {
    const ipx = (0, ipx_1.createIPX)({ ...opts, dir: (0, path_1.join)(cacheDir, 'cache') });
    if (!basePath.endsWith('/')) {
        basePath = `${basePath}/`;
    }
    if (localPrefix && !localPrefix.startsWith('/')) {
        localPrefix = `/${localPrefix}`;
    }
    const handler = async (event, _context) => {
        if (event.headers[SUBREQUEST_HEADER]) {
            // eslint-disable-next-line no-console
            console.error('Source image loop detected');
            return {
                statusCode: 400,
                body: 'Source image loop detected',
                headers: plainText
            };
        }
        let domains = opts.domains || [];
        const remoteURLPatterns = remotePatterns || [];
        const requestEtag = event.headers['if-none-match'];
        const eventPath = event.path.replace(basePath, '');
        // eslint-disable-next-line prefer-const
        let [modifiers = '_', ...segments] = eventPath.split('/');
        let id = decodeURIComponent(segments.join('/'));
        if (propsEncoding === 'base64') {
            const params = (0, utils_1.decodeBase64Params)(eventPath);
            if (params.error) {
                return {
                    statusCode: 400,
                    body: params.error,
                    headers: plainText
                };
            }
            id = params.id;
            modifiers = params.modifiers;
        }
        const requestHeaders = {
            [SUBREQUEST_HEADER]: '1'
        };
        const isLocal = !id.startsWith('http://') && !id.startsWith('https://');
        if (isLocal) {
            const url = new URL(event.rawUrl);
            url.pathname = id;
            if (localPrefix && !url.pathname.startsWith(localPrefix)) {
                return {
                    statusCode: 400,
                    body: 'Invalid source image path',
                    headers: plainText
                };
            }
            id = url.toString();
            if (event.headers.cookie) {
                requestHeaders.cookie = event.headers.cookie;
            }
            if (event.headers.authorization) {
                requestHeaders.authorization = event.headers.authorization;
            }
        }
        else {
            // Parse id as URL
            const parsedUrl = (0, ufo_1.parseURL)(id, 'https://');
            // Check host
            if (!parsedUrl.host) {
                return {
                    statusCode: 403,
                    body: 'Hostname is missing: ' + id,
                    headers: plainText
                };
            }
            if (!bypassDomainCheck) {
                let domainAllowed = false;
                if (domains.length > 0) {
                    if (typeof domains === 'string') {
                        domains = domains.split(',').map(s => s.trim());
                    }
                    const hosts = domains.map(domain => (0, ufo_1.parseURL)(domain, 'https://').host);
                    if (hosts.includes(parsedUrl.host)) {
                        domainAllowed = true;
                    }
                }
                if (remoteURLPatterns.length > 0) {
                    const matchingRemotePattern = remoteURLPatterns.find((remotePattern) => {
                        return (0, utils_1.doPatternsMatchUrl)(remotePattern, parsedUrl);
                    });
                    if (matchingRemotePattern) {
                        domainAllowed = true;
                    }
                }
                if (!domainAllowed) {
                    // eslint-disable-next-line no-console
                    console.log(`URL not on allowlist. Values provided are:
            domains: ${JSON.stringify(domains)}
            remotePatterns: ${JSON.stringify(remoteURLPatterns)}
          `);
                    return {
                        statusCode: 403,
                        body: 'URL not on allowlist: ' + id,
                        headers: plainText
                    };
                }
            }
        }
        const { response, cacheKey, responseEtag, finalize } = await (0, http_1.loadSourceImage)({
            cacheDir,
            url: id,
            requestEtag,
            modifiers,
            isLocal,
            requestHeaders
        });
        try {
            if (response) {
                return response;
            }
            const res = await (0, ipx_1.handleRequest)({
                url: `/${modifiers}/${cacheKey}`,
                headers: event.headers
            }, ipx);
            const body = typeof res.body === 'string' ? res.body : res.body.toString('base64');
            res.headers.etag = responseEtag || JSON.parse((0, etag_1.default)(body));
            delete res.headers['Last-Modified'];
            if (requestEtag && requestEtag === res.headers.etag) {
                return {
                    statusCode: 304,
                    message: 'Not Modified'
                };
            }
            if (responseHeaders) {
                for (const [header, value] of Object.entries(responseHeaders)) {
                    res.headers[header] = value;
                }
            }
            return {
                statusCode: res.statusCode,
                message: res.statusMessage,
                headers: res.headers,
                isBase64Encoded: typeof res.body !== 'string',
                body
            };
        }
        finally {
            await finalize();
        }
    };
    return (0, functions_1.builder)(handler);
}
exports.createIPXHandler = createIPXHandler;
