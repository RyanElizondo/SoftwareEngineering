"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const chalk_1 = require("chalk");
const destr_1 = __importDefault(require("destr"));
const fs_extra_1 = require("fs-extra");
const outdent_1 = require("outdent");
const constants_1 = require("./constants");
const cache_1 = require("./helpers/cache");
const config_1 = require("./helpers/config");
const dev_1 = require("./helpers/dev");
const edge_1 = require("./helpers/edge");
const files_1 = require("./helpers/files");
const functions_1 = require("./helpers/functions");
const redirects_1 = require("./helpers/redirects");
const utils_1 = require("./helpers/utils");
const verification_1 = require("./helpers/verification");
const plugin = {
    async onPreBuild({ constants, netlifyConfig, utils: { build: { failBuild }, cache, }, }) {
        var _a;
        const { publish } = netlifyConfig.build;
        if ((0, utils_1.shouldSkip)()) {
            await (0, cache_1.restoreCache)({ cache, publish });
            console.log('Not running Next Runtime');
            if ((0, fs_extra_1.existsSync)((0, path_1.join)(constants.INTERNAL_FUNCTIONS_SRC, constants_1.HANDLER_FUNCTION_NAME))) {
                console.log(`Please ensure you remove any generated functions from ${constants.INTERNAL_FUNCTIONS_SRC}`);
            }
            return;
        }
        (0, verification_1.checkForRootPublish)({ publish, failBuild });
        (0, verification_1.verifyNetlifyBuildVersion)({ failBuild, ...constants });
        await (0, cache_1.restoreCache)({ cache, publish });
        (_a = netlifyConfig.build).environment || (_a.environment = {});
        // eslint-disable-next-line unicorn/consistent-destructuring
        netlifyConfig.build.environment.NEXT_PRIVATE_TARGET = 'server';
    },
    async onBuild({ constants, netlifyConfig, utils: { build: { failBuild }, }, }) {
        if ((0, utils_1.shouldSkip)()) {
            return;
        }
        const { publish } = netlifyConfig.build;
        (0, verification_1.checkNextSiteHasBuilt)({ publish, failBuild });
        const { appDir, basePath, i18n, images, target, ignore, trailingSlash, outdir, experimental, routesManifest } = await (0, config_1.getNextConfig)({
            publish,
            failBuild,
        });
        await (0, edge_1.cleanupEdgeFunctions)(constants);
        const middlewareManifest = await (0, edge_1.loadMiddlewareManifest)(netlifyConfig);
        if ((middlewareManifest === null || middlewareManifest === void 0 ? void 0 : middlewareManifest.functions) &&
            Object.keys(middlewareManifest.functions).length !== 0 &&
            (0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE)) {
            failBuild((0, outdent_1.outdent) `
        You are using Next.js experimental edge runtime, but have set NEXT_DISABLE_NETLIFY_EDGE to true. This is not supported.
        To use edge runtime, remove the env var ${(0, chalk_1.bold) `NEXT_DISABLE_NETLIFY_EDGE`}.
      `);
        }
        if ((middlewareManifest === null || middlewareManifest === void 0 ? void 0 : middlewareManifest.middleware) &&
            Object.keys(middlewareManifest.middleware).length !== 0 &&
            (0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE)) {
            console.log((0, chalk_1.redBright)((0, outdent_1.outdent) `
          You are using Next.js Middleware without Netlify Edge Functions.
          This is deprecated because it negatively affects performance and will disable ISR and static rendering.
          It also disables advanced middleware features from @netlify/next
          To get the best performance and use Netlify Edge Functions, remove the env var ${(0, chalk_1.bold) `NEXT_DISABLE_NETLIFY_EDGE`}.
        `));
        }
        if ((0, utils_1.isNextAuthInstalled)()) {
            const config = await (0, config_1.getRequiredServerFiles)(publish);
            const userDefinedNextAuthUrl = config.config.env.NEXTAUTH_URL;
            if (userDefinedNextAuthUrl) {
                console.log(`NextAuth package detected, NEXTAUTH_URL environment variable set by user in next.config.js to ${userDefinedNextAuthUrl}`);
            }
            else if (process.env.NEXTAUTH_URL) {
                // When the value is specified in the netlify.toml or the Netlify UI (will be evaluated in this order)
                const nextAuthUrl = `${process.env.NEXTAUTH_URL}${basePath}`;
                console.log(`NextAuth package detected, NEXTAUTH_URL environment variable set by user in Netlify configuration to ${nextAuthUrl}`);
                config.config.env.NEXTAUTH_URL = nextAuthUrl;
                await (0, config_1.updateRequiredServerFiles)(publish, config);
            }
            else {
                // Using the deploy prime url in production leads to issues because the unique deploy ID is part of the generated URL
                // and will not match the expected URL in the callback URL of an OAuth application.
                const nextAuthUrl = `${process.env.CONTEXT === 'production' ? process.env.URL : process.env.DEPLOY_PRIME_URL}${basePath}`;
                console.log(`NextAuth package detected, setting NEXTAUTH_URL environment variable to ${nextAuthUrl}`);
                config.config.env.NEXTAUTH_URL = nextAuthUrl;
                await (0, config_1.updateRequiredServerFiles)(publish, config);
            }
        }
        const buildId = (0, fs_extra_1.readFileSync)((0, path_1.join)(publish, 'BUILD_ID'), 'utf8').trim();
        await (0, config_1.configureHandlerFunctions)({ netlifyConfig, ignore, publish: (0, path_1.relative)(process.cwd(), publish) });
        const apiRoutes = await (0, functions_1.getExtendedApiRouteConfigs)(publish, appDir);
        await (0, functions_1.generateFunctions)(constants, appDir, apiRoutes);
        await (0, functions_1.generatePagesResolver)(constants);
        await (0, files_1.movePublicFiles)({ appDir, outdir, publish, basePath });
        await (0, files_1.patchNextFiles)(appDir);
        if (!(0, destr_1.default)(process.env.SERVE_STATIC_FILES_FROM_ORIGIN)) {
            await (0, files_1.moveStaticPages)({ target, netlifyConfig, i18n, basePath });
        }
        await (0, redirects_1.generateStaticRedirects)({
            netlifyConfig,
            nextConfig: { basePath, i18n },
        });
        await (0, functions_1.setupImageFunction)({
            constants,
            imageconfig: images,
            netlifyConfig,
            basePath,
            remotePatterns: (0, utils_1.getRemotePatterns)(experimental, images),
            responseHeaders: (0, utils_1.getCustomImageResponseHeaders)(netlifyConfig.headers),
        });
        await (0, redirects_1.generateRedirects)({
            netlifyConfig,
            nextConfig: { basePath, i18n, trailingSlash, appDir },
            buildId,
            apiRoutes,
        });
        await (0, edge_1.writeEdgeFunctions)({ netlifyConfig, routesManifest });
    },
    async onPostBuild({ netlifyConfig: { build: { publish }, redirects, headers, }, utils: { status, cache, functions, build: { failBuild }, }, constants: { FUNCTIONS_DIST }, }) {
        await (0, cache_1.saveCache)({ cache, publish });
        if ((0, utils_1.shouldSkip)()) {
            status.show({
                title: 'Next Runtime did not run',
                summary: `Next cache was stored, but all other functions were skipped because ${process.env.NETLIFY_NEXT_PLUGIN_SKIP
                    ? `NETLIFY_NEXT_PLUGIN_SKIP is set`
                    : `NEXT_PLUGIN_FORCE_RUN is set to ${process.env.NEXT_PLUGIN_FORCE_RUN}`}`,
            });
            return;
        }
        await (0, verification_1.checkForOldFunctions)({ functions });
        await (0, verification_1.checkZipSize)((0, path_1.join)(FUNCTIONS_DIST, `${constants_1.ODB_FUNCTION_NAME}.zip`));
        const nextConfig = await (0, config_1.getNextConfig)({ publish, failBuild });
        const { basePath, appDir, experimental } = nextConfig;
        (0, config_1.generateCustomHeaders)(nextConfig, headers);
        (0, verification_1.warnForProblematicUserRewrites)({ basePath, redirects });
        (0, verification_1.warnForRootRedirects)({ appDir });
        await (0, functions_1.warnOnApiRoutes)({ FUNCTIONS_DIST });
        if (experimental === null || experimental === void 0 ? void 0 : experimental.appDir) {
            console.log('ðŸ§ª Thank you for testing "appDir" support on Netlify. For known issues and to give feedback, visit https://ntl.fyi/next-13-feedback');
        }
    },
};
// The types haven't been updated yet
const nextRuntime = (_inputs, meta = {}) => {
    var _a;
    if (!((_a = meta === null || meta === void 0 ? void 0 : meta.events) === null || _a === void 0 ? void 0 : _a.has('onPreDev'))) {
        return {
            ...plugin,
            onEnd: ({ utils }) => {
                utils.status.show({
                    title: 'Please upgrade to the latest version of the Netlify CLI',
                    summary: 'To support for the latest Next.js features, please upgrade to the latest version of the Netlify CLI',
                });
            },
        };
    }
    return {
        ...plugin,
        onPreDev: dev_1.onPreDev,
    };
};
module.exports = nextRuntime;
