"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeEdgeFunctions = exports.getEdgeFunctionPatternForPage = exports.writeRscDataEdgeFunction = exports.writeDevEdgeFunction = exports.cleanupEdgeFunctions = exports.loadPrerenderManifest = exports.loadAppPathRoutesManifest = exports.loadMiddlewareManifest = exports.isAppDirRoute = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const chalk_1 = require("chalk");
const destr_1 = __importDefault(require("destr"));
const fs_extra_1 = require("fs-extra");
const outdent_1 = require("outdent");
const constants_1 = require("../constants");
const config_1 = require("./config");
const matchers_1 = require("./matchers");
const maybeLoadJson = (path) => {
    if ((0, fs_1.existsSync)(path)) {
        return (0, fs_extra_1.readJSON)(path);
    }
};
const isAppDirRoute = (route, appPathRoutesManifest) => Boolean(appPathRoutesManifest) && Object.values(appPathRoutesManifest).includes(route);
exports.isAppDirRoute = isAppDirRoute;
const loadMiddlewareManifest = (netlifyConfig) => maybeLoadJson((0, path_1.resolve)(netlifyConfig.build.publish, 'server', 'middleware-manifest.json'));
exports.loadMiddlewareManifest = loadMiddlewareManifest;
const loadAppPathRoutesManifest = (netlifyConfig) => maybeLoadJson((0, path_1.resolve)(netlifyConfig.build.publish, 'app-path-routes-manifest.json'));
exports.loadAppPathRoutesManifest = loadAppPathRoutesManifest;
const loadPrerenderManifest = (netlifyConfig) => (0, fs_extra_1.readJSON)((0, path_1.resolve)(netlifyConfig.build.publish, 'prerender-manifest.json'));
exports.loadPrerenderManifest = loadPrerenderManifest;
/**
 * Convert the Next middleware name into a valid Edge Function name
 */
const sanitizeName = (name) => `next_${name.replace(/\W/g, '_')}`;
// Slightly different spacing in different versions!
const IMPORT_UNSUPPORTED = [
    `Object.defineProperty(globalThis,"__import_unsupported"`,
    `    Object.defineProperty(globalThis, "__import_unsupported"`,
];
/**
 * Concatenates the Next edge function code with the required chunks and adds an export
 */
const getMiddlewareBundle = async ({ edgeFunctionDefinition, netlifyConfig, }) => {
    const { publish } = netlifyConfig.build;
    const shims = await fs_1.promises.readFile(getEdgeTemplatePath('shims.js'), 'utf8');
    const chunks = [shims];
    chunks.push(`export const _DEFINITION = ${JSON.stringify(edgeFunctionDefinition)}`);
    if ('wasm' in edgeFunctionDefinition) {
        for (const { name, filePath } of edgeFunctionDefinition.wasm) {
            const wasm = await fs_1.promises.readFile((0, path_1.join)(publish, filePath));
            chunks.push(`const ${name} = _base64Decode(${JSON.stringify(wasm.toString('base64'))}).buffer`);
        }
    }
    if ('assets' in edgeFunctionDefinition) {
        chunks.push(`const _ASSETS = {}`);
        for (const { name, filePath } of edgeFunctionDefinition.assets) {
            const wasm = await fs_1.promises.readFile((0, path_1.join)(publish, filePath));
            chunks.push(`_ASSETS[${JSON.stringify(name)}] = ${JSON.stringify(wasm.toString('base64'))}`);
        }
    }
    for (const file of edgeFunctionDefinition.files) {
        const filePath = (0, path_1.join)(publish, file);
        let data = await fs_1.promises.readFile(filePath, 'utf8');
        // Next defines an immutable global variable, which is fine unless you have more than one in the bundle
        // This adds a check to see if the global is already defined
        data = IMPORT_UNSUPPORTED.reduce((acc, val) => acc.replace(val, `('__import_unsupported' in globalThis)||${val}`), data);
        chunks.push('{', data, '}');
    }
    const exports = /* js */ `export default _ENTRIES["middleware_${edgeFunctionDefinition.name}"].default;`;
    chunks.push(exports);
    return chunks.join('\n');
};
const getEdgeTemplatePath = (file) => (0, path_1.join)(__dirname, '..', '..', 'src', 'templates', 'edge', file);
const copyEdgeSourceFile = ({ file, target, edgeFunctionDir, }) => fs_1.promises.copyFile(getEdgeTemplatePath(file), (0, path_1.join)(edgeFunctionDir, target !== null && target !== void 0 ? target : file));
const writeEdgeFunction = async ({ edgeFunctionDefinition, edgeFunctionRoot, netlifyConfig, functionName, matchers = [], middleware = false, }) => {
    const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, functionName);
    const bundle = await getMiddlewareBundle({
        edgeFunctionDefinition,
        netlifyConfig,
    });
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await fs_1.promises.writeFile((0, path_1.join)(edgeFunctionDir, 'bundle.js'), bundle);
    await copyEdgeSourceFile({
        edgeFunctionDir,
        file: middleware ? 'middleware-runtime.ts' : 'function-runtime.ts',
        target: 'index.ts',
    });
    if (middleware) {
        // Functions don't have complex matchers, so we can rely on the Netlify matcher
        await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionDir, 'matchers.json'), matchers);
    }
};
const generateEdgeFunctionMiddlewareMatchers = ({ edgeFunctionDefinition, nextConfig, }) => {
    // The v1 middleware manifest has a single regexp, but the v2 has an array of matchers
    if ('regexp' in edgeFunctionDefinition) {
        return [{ regexp: edgeFunctionDefinition.regexp }];
    }
    if (nextConfig.i18n) {
        return edgeFunctionDefinition.matchers.map((matcher) => ({
            ...matcher,
            regexp: (0, matchers_1.makeLocaleOptional)(matcher.regexp),
        }));
    }
    return edgeFunctionDefinition.matchers;
};
const middlewareMatcherToEdgeFunctionDefinition = (matcher, name, cache) => {
    const pattern = (0, matchers_1.transformCaptureGroups)((0, matchers_1.stripLookahead)(matcher.regexp));
    return { function: name, pattern, name, cache };
};
const cleanupEdgeFunctions = ({ INTERNAL_EDGE_FUNCTIONS_SRC = '.netlify/edge-functions', }) => (0, fs_extra_1.emptyDir)(INTERNAL_EDGE_FUNCTIONS_SRC);
exports.cleanupEdgeFunctions = cleanupEdgeFunctions;
const writeDevEdgeFunction = async ({ INTERNAL_EDGE_FUNCTIONS_SRC = '.netlify/edge-functions', }) => {
    const manifest = {
        functions: [
            {
                function: 'next-dev',
                name: 'netlify dev handler',
                path: '/*',
            },
        ],
        version: 1,
    };
    const edgeFunctionRoot = (0, path_1.resolve)(INTERNAL_EDGE_FUNCTIONS_SRC);
    await (0, fs_extra_1.emptyDir)(edgeFunctionRoot);
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionRoot, 'manifest.json'), manifest);
    await (0, fs_extra_1.copy)(getEdgeTemplatePath('../edge-shared'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared'));
    const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, 'next-dev');
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await copyEdgeSourceFile({ edgeFunctionDir, file: 'next-dev.js', target: 'index.js' });
};
exports.writeDevEdgeFunction = writeDevEdgeFunction;
/**
 * Writes an edge function that routes RSC data requests to the `.rsc` route
 */
const writeRscDataEdgeFunction = async ({ prerenderManifest, appPathRoutesManifest, }) => {
    if (!prerenderManifest || !appPathRoutesManifest) {
        return [];
    }
    const staticAppdirRoutes = [];
    for (const [path, route] of Object.entries(prerenderManifest.routes)) {
        if ((0, exports.isAppDirRoute)(route.srcRoute, appPathRoutesManifest)) {
            staticAppdirRoutes.push(path, route.dataRoute);
        }
    }
    const dynamicAppDirRoutes = [];
    for (const [path, route] of Object.entries(prerenderManifest.dynamicRoutes)) {
        if ((0, exports.isAppDirRoute)(path, appPathRoutesManifest)) {
            dynamicAppDirRoutes.push(route.routeRegex, route.dataRouteRegex);
        }
    }
    if (staticAppdirRoutes.length === 0 && dynamicAppDirRoutes.length === 0) {
        return [];
    }
    const edgeFunctionDir = (0, path_1.resolve)('.netlify', 'edge-functions', 'rsc-data');
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await copyEdgeSourceFile({ edgeFunctionDir, file: 'rsc-data.ts' });
    return [
        ...staticAppdirRoutes.map((path) => ({
            function: 'rsc-data',
            name: 'RSC data routing',
            path,
        })),
        ...dynamicAppDirRoutes.map((pattern) => ({
            function: 'rsc-data',
            name: 'RSC data routing',
            pattern,
        })),
    ];
};
exports.writeRscDataEdgeFunction = writeRscDataEdgeFunction;
const getEdgeFunctionPatternForPage = ({ edgeFunctionDefinition, pageRegexMap, appPathRoutesManifest, }) => {
    // We don't just use the matcher from the edge function definition, because it doesn't handle trailing slashes
    var _a, _b;
    // appDir functions have a name that _isn't_ the route name, but rather the route with `/page` appended
    const regexp = pageRegexMap.get((_a = appPathRoutesManifest === null || appPathRoutesManifest === void 0 ? void 0 : appPathRoutesManifest[edgeFunctionDefinition.page]) !== null && _a !== void 0 ? _a : edgeFunctionDefinition.page);
    if (regexp) {
        return regexp;
    }
    if ('regexp' in edgeFunctionDefinition) {
        return edgeFunctionDefinition.regexp.replace(/([^/])\$$/, '$1/?$');
    }
    // If we need to fall back to the matcher, we need to add an optional trailing slash
    return (_b = edgeFunctionDefinition.matchers) === null || _b === void 0 ? void 0 : _b[0].regexp.replace(/([^/])\$$/, '$1/?$');
};
exports.getEdgeFunctionPatternForPage = getEdgeFunctionPatternForPage;
/**
 * Writes Edge Functions for the Next middleware
 */
// eslint-disable-next-line max-lines-per-function
const writeEdgeFunctions = async ({ netlifyConfig, routesManifest, }) => {
    var _a;
    const manifest = {
        functions: [],
        version: 1,
    };
    const edgeFunctionRoot = (0, path_1.resolve)('.netlify', 'edge-functions');
    await (0, fs_extra_1.emptyDir)(edgeFunctionRoot);
    const { publish } = netlifyConfig.build;
    const nextConfigFile = await (0, config_1.getRequiredServerFiles)(publish);
    const nextConfig = nextConfigFile.config;
    const usesAppDir = (_a = nextConfig.experimental) === null || _a === void 0 ? void 0 : _a.appDir;
    await (0, fs_extra_1.copy)(getEdgeTemplatePath('../edge-shared'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared'));
    await (0, fs_extra_1.writeJSON)((0, path_1.join)(edgeFunctionRoot, 'edge-shared', 'nextConfig.json'), nextConfig);
    await (0, fs_extra_1.copy)((0, path_1.join)(publish, 'prerender-manifest.json'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared', 'prerender-manifest.json'));
    // early return if edge is disabled
    if ((0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE)) {
        console.log('Environment variable NEXT_DISABLE_NETLIFY_EDGE has been set, skipping Netlify Edge Function creation.');
        return;
    }
    const rscFunctions = await (0, exports.writeRscDataEdgeFunction)({
        prerenderManifest: await (0, exports.loadPrerenderManifest)(netlifyConfig),
        appPathRoutesManifest: await (0, exports.loadAppPathRoutesManifest)(netlifyConfig),
    });
    manifest.functions.push(...rscFunctions);
    const middlewareManifest = await (0, exports.loadMiddlewareManifest)(netlifyConfig);
    if (!middlewareManifest) {
        console.error("Couldn't find the middleware manifest");
        return;
    }
    let usesEdge = false;
    for (const middleware of middlewareManifest.sortedMiddleware) {
        usesEdge = true;
        const edgeFunctionDefinition = middlewareManifest.middleware[middleware];
        const functionName = sanitizeName(edgeFunctionDefinition.name);
        const matchers = generateEdgeFunctionMiddlewareMatchers({
            edgeFunctionDefinition,
            edgeFunctionRoot,
            nextConfig,
        });
        await writeEdgeFunction({
            edgeFunctionDefinition,
            edgeFunctionRoot,
            netlifyConfig,
            functionName,
            matchers,
            middleware: true,
        });
        manifest.functions.push(...matchers.map((matcher) => middlewareMatcherToEdgeFunctionDefinition(matcher, functionName)));
    }
    // Functions (i.e. not middleware, but edge SSR and API routes)
    if (typeof middlewareManifest.functions === 'object') {
        // When using the app dir, we also need to check if the EF matches a page
        const appPathRoutesManifest = await (0, exports.loadAppPathRoutesManifest)(netlifyConfig);
        // A map of all route pages to their page regex. This is used for pages dir and appDir.
        const pageRegexMap = new Map([...(routesManifest.dynamicRoutes || []), ...(routesManifest.staticRoutes || [])].map((route) => [
            route.page,
            route.regex,
        ]));
        // Create a map of pages-dir routes to their data route regex (appDir uses the same route as the HTML)
        const dataRoutesMap = new Map([...(routesManifest.dataRoutes || [])].map((route) => [route.page, route.dataRouteRegex]));
        for (const edgeFunctionDefinition of Object.values(middlewareManifest.functions)) {
            usesEdge = true;
            const functionName = sanitizeName(edgeFunctionDefinition.name);
            await writeEdgeFunction({
                edgeFunctionDefinition,
                edgeFunctionRoot,
                netlifyConfig,
                functionName,
            });
            const pattern = (0, exports.getEdgeFunctionPatternForPage)({
                edgeFunctionDefinition,
                pageRegexMap,
                appPathRoutesManifest,
            });
            manifest.functions.push({
                function: functionName,
                name: edgeFunctionDefinition.name,
                pattern,
                // cache: "manual" is currently experimental, so we restrict it to sites that use experimental appDir
                cache: usesAppDir ? 'manual' : undefined,
            });
            // pages-dir page routes also have a data route. If there's a match, add an entry mapping that to the function too
            const dataRoute = dataRoutesMap.get(edgeFunctionDefinition.page);
            if (dataRoute) {
                manifest.functions.push({
                    function: functionName,
                    name: edgeFunctionDefinition.name,
                    pattern: dataRoute,
                    cache: usesAppDir ? 'manual' : undefined,
                });
            }
        }
    }
    if ((0, destr_1.default)(process.env.NEXT_FORCE_EDGE_IMAGES) &&
        !(0, destr_1.default)(process.env.NEXT_DISABLE_EDGE_IMAGES) &&
        !(0, destr_1.default)(process.env.DISABLE_IPX)) {
        usesEdge = true;
        console.log('Using Netlify Edge Functions for image format detection. Set env var "NEXT_DISABLE_EDGE_IMAGES=true" to disable.');
        const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, 'ipx');
        await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
        await copyEdgeSourceFile({ edgeFunctionDir, file: 'ipx.ts', target: 'index.ts' });
        await (0, fs_extra_1.copyFile)((0, path_1.join)('.netlify', 'functions-internal', constants_1.IMAGE_FUNCTION_NAME, 'imageconfig.json'), (0, path_1.join)(edgeFunctionDir, 'imageconfig.json'));
        manifest.functions.push({
            function: 'ipx',
            name: 'next/image handler',
            path: '/_next/image*',
        });
    }
    else {
        console.log('You are not using Netlify Edge Functions for image format detection. Set env var "NEXT_FORCE_EDGE_IMAGES=true" to enable.');
    }
    if (usesEdge) {
        console.log((0, outdent_1.outdent) `
      ✨ Deploying middleware and functions to ${(0, chalk_1.greenBright) `Netlify Edge Functions`} ✨
      This feature is in beta. Please share your feedback here: https://ntl.fyi/next-netlify-edge
    `);
    }
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionRoot, 'manifest.json'), manifest);
};
exports.writeEdgeFunctions = writeEdgeFunctions;
