"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeStringRegexp = exports.getRemotePatterns = exports.isBundleSizeCheckDisabled = exports.getCustomImageResponseHeaders = exports.isNextAuthInstalled = exports.findModuleFromBase = exports.shouldSkip = exports.getPreviewRewrites = exports.getApiRewrites = exports.redirectsForNextRouteWithData = exports.redirectsForNext404Route = exports.redirectsForNextRoute = exports.is404Route = exports.isApiRoute = exports.localizeRoute = exports.routeToDataRoute = exports.generateNetlifyRoutes = exports.toNetlifyRoute = exports.getFunctionNameForPage = void 0;
const globby_1 = __importDefault(require("globby"));
const pathe_1 = require("pathe");
const constants_1 = require("../constants");
const RESERVED_FILENAME = /[^\w_-]/g;
/**
 * Given a Next route, generates a valid Netlify function name.
 * If "background" is true then the function name will have `-background`
 * appended to it, meaning that it is executed as a background function.
 */
const getFunctionNameForPage = (page, background = false) => `${page
    .replace(constants_1.CATCH_ALL_REGEX, '_$1-SPLAT')
    .replace(constants_1.OPTIONAL_CATCH_ALL_REGEX, '-SPLAT')
    .replace(constants_1.DYNAMIC_PARAMETER_REGEX, '_$1-PARAM')
    .replace(RESERVED_FILENAME, '_')}-${background ? 'background' : 'handler'}`;
exports.getFunctionNameForPage = getFunctionNameForPage;
const toNetlifyRoute = (nextRoute) => {
    const netlifyRoutes = [nextRoute];
    // If the route is an optional catch-all route, we need to add a second
    // Netlify route for the base path (when no parameters are present).
    // The file ending must be present!
    if (constants_1.OPTIONAL_CATCH_ALL_REGEX.test(nextRoute)) {
        let netlifyRoute = nextRoute.replace(constants_1.OPTIONAL_CATCH_ALL_REGEX, '$2');
        // create an empty string, but actually needs to be a forward slash
        if (netlifyRoute === '') {
            netlifyRoute = '/';
        }
        // When optional catch-all route is at top-level, the regex on line 19 will
        // create an incorrect route for the data route. For example, it creates
        // /_next/data/%BUILDID%.json, but NextJS looks for
        // /_next/data/%BUILDID%/index.json
        netlifyRoute = netlifyRoute.replace(/(\/_next\/data\/[^/]+).json/, '$1/index.json');
        // Add second route to the front of the array
        netlifyRoutes.unshift(netlifyRoute);
    }
    return netlifyRoutes.map((route) => route
        // Replace catch-all, e.g., [...slug]
        .replace(constants_1.CATCH_ALL_REGEX, '/:$1/*')
        // Replace optional catch-all, e.g., [[...slug]]
        .replace(constants_1.OPTIONAL_CATCH_ALL_REGEX, '/*')
        // Replace dynamic parameters, e.g., [id]
        .replace(constants_1.DYNAMIC_PARAMETER_REGEX, '/:$1'));
};
exports.toNetlifyRoute = toNetlifyRoute;
const generateNetlifyRoutes = ({ route, dataRoute, withData = true, }) => [...(withData ? (0, exports.toNetlifyRoute)(dataRoute) : []), ...(0, exports.toNetlifyRoute)(route)];
exports.generateNetlifyRoutes = generateNetlifyRoutes;
const routeToDataRoute = (route, buildId, locale) => `/_next/data/${buildId}${locale ? `/${locale}` : ''}${route === '/' ? (locale ? '' : '/index') : route}.json`;
exports.routeToDataRoute = routeToDataRoute;
// Default locale is served from root, not localized
const localizeRoute = (route, locale, defaultLocale) => locale === defaultLocale ? route : `/${locale}${route}`;
exports.localizeRoute = localizeRoute;
const netlifyRoutesForNextRoute = ({ route, buildId, i18n, withData = true, dataRoute, }) => {
    var _a;
    if (!((_a = i18n === null || i18n === void 0 ? void 0 : i18n.locales) === null || _a === void 0 ? void 0 : _a.length)) {
        return (0, exports.generateNetlifyRoutes)({ route, dataRoute: dataRoute || (0, exports.routeToDataRoute)(route, buildId), withData }).map((redirect) => ({
            redirect,
            locale: false,
        }));
    }
    const { locales, defaultLocale } = i18n;
    const routes = [];
    locales.forEach((locale) => {
        // Data route is always localized, except for appDir
        const localizedDataRoute = dataRoute
            ? (0, exports.localizeRoute)(dataRoute, locale, defaultLocale)
            : (0, exports.routeToDataRoute)(route, buildId, locale);
        routes.push(...(0, exports.generateNetlifyRoutes)({
            route: (0, exports.localizeRoute)(route, locale, defaultLocale),
            dataRoute: localizedDataRoute,
            withData,
        }).map((redirect) => ({
            redirect,
            locale,
        })));
    });
    return routes;
};
const isApiRoute = (route) => route.startsWith('/api/') || route === '/api';
exports.isApiRoute = isApiRoute;
const is404Route = (route, i18n) => i18n ? i18n.locales.some((locale) => route === `/${locale}/404`) : route === '/404';
exports.is404Route = is404Route;
const redirectsForNextRoute = ({ route, buildId, basePath, to, i18n, status = 200, force = false, withData = true, dataRoute, }) => netlifyRoutesForNextRoute({ route, buildId, i18n, withData, dataRoute }).map(({ redirect }) => ({
    from: `${basePath}${redirect}`,
    to,
    status,
    force,
}));
exports.redirectsForNextRoute = redirectsForNextRoute;
const redirectsForNext404Route = ({ route, buildId, basePath, i18n, force = false, }) => netlifyRoutesForNextRoute({ route, buildId, i18n }).map(({ redirect, locale }) => ({
    from: `${basePath}${redirect}`,
    to: locale ? `${basePath}/server/pages/${locale}/404.html` : `${basePath}/server/pages/404.html`,
    status: 404,
    force,
}));
exports.redirectsForNext404Route = redirectsForNext404Route;
const redirectsForNextRouteWithData = ({ route, dataRoute, basePath, to, status = 200, force = false, }) => (0, exports.generateNetlifyRoutes)({ route, dataRoute, withData: true }).map((redirect) => ({
    from: `${basePath}${redirect}`,
    to,
    status,
    force,
}));
exports.redirectsForNextRouteWithData = redirectsForNextRouteWithData;
const getApiRewrites = (basePath, apiRoutes) => {
    const apiRewrites = apiRoutes.map((apiRoute) => {
        const [from] = (0, exports.toNetlifyRoute)(`${basePath}${apiRoute.route}`);
        // Scheduled functions can't be invoked directly, so we 404 them.
        if (apiRoute.config.type === "experimental-scheduled" /* ApiRouteType.SCHEDULED */) {
            return { from, to: '/404.html', status: 404 };
        }
        return {
            from,
            to: `/.netlify/functions/${(0, exports.getFunctionNameForPage)(apiRoute.route, apiRoute.config.type === "experimental-background" /* ApiRouteType.BACKGROUND */)}`,
            status: 200,
        };
    });
    return [
        ...apiRewrites,
        {
            from: `${basePath}/api/*`,
            to: constants_1.HANDLER_FUNCTION_PATH,
            status: 200,
        },
    ];
};
exports.getApiRewrites = getApiRewrites;
const getPreviewRewrites = async ({ basePath, appDir }) => {
    const publicFiles = await (0, globby_1.default)('**/*', { cwd: (0, pathe_1.join)(appDir, 'public') });
    // Preview mode gets forced to the function, to bypass pre-rendered pages, but static files need to be skipped
    return [
        ...publicFiles.map((file) => ({
            from: `${basePath}/${file}`,
            // This is a no-op, but we do it to stop it matching the following rule
            to: `${basePath}/${file}`,
            conditions: { Cookie: ['__prerender_bypass', '__next_preview_data'] },
            status: 200,
        })),
        {
            from: `${basePath}/*`,
            to: constants_1.HANDLER_FUNCTION_PATH,
            status: 200,
            conditions: { Cookie: ['__prerender_bypass', '__next_preview_data'] },
            force: true,
        },
    ];
};
exports.getPreviewRewrites = getPreviewRewrites;
const shouldSkip = () => process.env.NEXT_PLUGIN_FORCE_RUN === 'false' ||
    process.env.NEXT_PLUGIN_FORCE_RUN === '0' ||
    process.env.NETLIFY_NEXT_PLUGIN_SKIP === 'true' ||
    process.env.NETLIFY_NEXT_PLUGIN_SKIP === '1';
exports.shouldSkip = shouldSkip;
/**
 * Given an array of base paths and candidate modules, return the first one that exists
 */
const findModuleFromBase = ({ paths, candidates }) => {
    for (const candidate of candidates) {
        try {
            const modulePath = require.resolve(candidate, { paths });
            if (modulePath) {
                return modulePath;
            }
        }
        catch {
            // Ignore the error
        }
    }
    return null;
};
exports.findModuleFromBase = findModuleFromBase;
const isNextAuthInstalled = () => {
    try {
        // eslint-disable-next-line import/no-unassigned-import, import/no-extraneous-dependencies, n/no-extraneous-require
        require('next-auth');
        return true;
    }
    catch {
        // Ignore the MODULE_NOT_FOUND error
        return false;
    }
};
exports.isNextAuthInstalled = isNextAuthInstalled;
const getCustomImageResponseHeaders = (headers) => {
    const customImageResponseHeaders = headers.find((header) => { var _a; return (_a = header.for) === null || _a === void 0 ? void 0 : _a.startsWith('/_next/image/'); });
    if (customImageResponseHeaders) {
        return customImageResponseHeaders === null || customImageResponseHeaders === void 0 ? void 0 : customImageResponseHeaders.values;
    }
    return null;
};
exports.getCustomImageResponseHeaders = getCustomImageResponseHeaders;
const isBundleSizeCheckDisabled = () => process.env.DISABLE_BUNDLE_ZIP_SIZE_CHECK === '1' || process.env.DISABLE_BUNDLE_ZIP_SIZE_CHECK === 'true';
exports.isBundleSizeCheckDisabled = isBundleSizeCheckDisabled;
const getRemotePatterns = (experimental, images) => {
    var _a;
    // Where remote patterns is configured pre-v12.2.5
    if ((_a = experimental.images) === null || _a === void 0 ? void 0 : _a.remotePatterns) {
        return experimental.images.remotePatterns;
    }
    // Where remote patterns is configured after v12.2.5
    if (images.remotePatterns) {
        return images.remotePatterns || [];
    }
    return [];
};
exports.getRemotePatterns = getRemotePatterns;
// Taken from next/src/shared/lib/escape-regexp.ts
const reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
const reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
const escapeStringRegexp = (str) => (reHasRegExp.test(str) ? str.replace(reReplaceRegExp, '\\$&') : str);
exports.escapeStringRegexp = escapeStringRegexp;
