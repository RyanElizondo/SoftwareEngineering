"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeLocaleOptional = exports.transformCaptureGroups = exports.stripLookahead = void 0;
const regexp_tree_1 = require("regexp-tree");
// The Go regexp lib doesn't support lookaheads, so we need to remove them
const stripLookahead = (regex) => {
    // Early return if there's no lookahead
    if (!(regex === null || regex === void 0 ? void 0 : regex.includes('(?!'))) {
        return regex;
    }
    try {
        // Parse the regexp into an AST
        const re = (0, regexp_tree_1.transform)(`/${regex}/`, {
            Assertion(path) {
                // Remove the lookahead
                if (path.node.kind === 'Lookahead') {
                    path.remove();
                }
            },
        });
        // Strip the leading and trailing slashes
        return re.toString().slice(1, -1);
    }
    catch {
        //  Failed to parse regex, so return unchanged
        return regex;
    }
};
exports.stripLookahead = stripLookahead;
// The Go regexp lib has alternative syntax for named capture groups
const transformCaptureGroups = (regex) => regex.replace(/\(\?<\w+>/, '(');
exports.transformCaptureGroups = transformCaptureGroups;
const LOCALIZED_REGEX_PREFIX = '(?:\\/(_next\\/data\\/[^/]{1,}))?(?:\\/([^/.]{1,}))';
const OPTIONAL_REGEX_PREFIX = '(?:\\/(_next\\/data\\/[^/]{1,}))?(?:\\/([^/.]{1,}))?';
// Make the locale section of the matcher regex optional
const makeLocaleOptional = (regex) => regex.replace(LOCALIZED_REGEX_PREFIX, OPTIONAL_REGEX_PREFIX);
exports.makeLocaleOptional = makeLocaleOptional;
