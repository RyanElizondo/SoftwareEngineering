"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.warnOnApiRoutes = exports.getExtendedApiRouteConfigs = exports.getApiRouteConfigs = exports.setupImageFunction = exports.generatePagesResolver = exports.generateFunctions = void 0;
const node_bridge_1 = __importDefault(require("@vercel/node-bridge"));
const chalk_1 = __importDefault(require("chalk"));
const destr_1 = __importDefault(require("destr"));
const fs_extra_1 = require("fs-extra");
const outdent_1 = require("outdent");
const pathe_1 = require("pathe");
const constants_1 = require("../constants");
const getApiHandler_1 = require("../templates/getApiHandler");
const getHandler_1 = require("../templates/getHandler");
const getPageResolver_1 = require("../templates/getPageResolver");
const analysis_1 = require("./analysis");
const files_1 = require("./files");
const functionsMetaData_1 = require("./functionsMetaData");
const utils_1 = require("./utils");
const generateFunctions = async ({ FUNCTIONS_SRC = constants_1.DEFAULT_FUNCTIONS_SRC, INTERNAL_FUNCTIONS_SRC, PUBLISH_DIR }, appDir, apiRoutes) => {
    const publish = (0, pathe_1.resolve)(PUBLISH_DIR);
    const functionsDir = (0, pathe_1.resolve)(INTERNAL_FUNCTIONS_SRC || FUNCTIONS_SRC);
    const functionDir = (0, pathe_1.join)(functionsDir, constants_1.HANDLER_FUNCTION_NAME);
    const publishDir = (0, pathe_1.relative)(functionDir, publish);
    for (const { route, config, compiled } of apiRoutes) {
        // Don't write a lambda if the runtime is edge
        if (config.runtime === 'experimental-edge') {
            continue;
        }
        const apiHandlerSource = await (0, getApiHandler_1.getApiHandler)({
            page: route,
            config,
            publishDir,
            appDir: (0, pathe_1.relative)(functionDir, appDir),
        });
        const functionName = (0, utils_1.getFunctionNameForPage)(route, config.type === "experimental-background" /* ApiRouteType.BACKGROUND */);
        await (0, fs_extra_1.ensureDir)((0, pathe_1.join)(functionsDir, functionName));
        // write main API handler file
        await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, `${functionName}.js`), apiHandlerSource);
        // copy handler dependencies (VercelNodeBridge, NetlifyNextServer, etc.)
        await (0, fs_extra_1.copyFile)(node_bridge_1.default, (0, pathe_1.join)(functionsDir, functionName, 'bridge.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'server.js'), (0, pathe_1.join)(functionsDir, functionName, 'server.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'handlerUtils.js'), (0, pathe_1.join)(functionsDir, functionName, 'handlerUtils.js'));
        const resolveSourceFile = (file) => (0, pathe_1.join)(publish, 'server', file);
        const resolverSource = await (0, getPageResolver_1.getResolverForSourceFiles)({
            functionsDir,
            // These extra pages are always included by Next.js
            sourceFiles: [compiled, 'pages/_app.js', 'pages/_document.js', 'pages/_error.js'].map(resolveSourceFile),
        });
        await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, 'pages.js'), resolverSource);
    }
    const writeHandler = async (functionName, functionTitle, isODB) => {
        const handlerSource = await (0, getHandler_1.getHandler)({ isODB, publishDir, appDir: (0, pathe_1.relative)(functionDir, appDir) });
        await (0, fs_extra_1.ensureDir)((0, pathe_1.join)(functionsDir, functionName));
        // write main handler file (standard or ODB)
        await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsDir, functionName, `${functionName}.js`), handlerSource);
        // copy handler dependencies (VercelNodeBridge, NetlifyNextServer, etc.)
        await (0, fs_extra_1.copyFile)(node_bridge_1.default, (0, pathe_1.join)(functionsDir, functionName, 'bridge.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'server.js'), (0, pathe_1.join)(functionsDir, functionName, 'server.js'));
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'handlerUtils.js'), (0, pathe_1.join)(functionsDir, functionName, 'handlerUtils.js'));
        (0, functionsMetaData_1.writeFunctionConfiguration)({ functionName, functionTitle, functionsDir });
    };
    await writeHandler(constants_1.HANDLER_FUNCTION_NAME, constants_1.HANDLER_FUNCTION_TITLE, false);
    await writeHandler(constants_1.ODB_FUNCTION_NAME, constants_1.ODB_FUNCTION_TITLE, true);
};
exports.generateFunctions = generateFunctions;
/**
 * Writes a file in each function directory that contains references to every page entrypoint.
 * This is just so that the nft bundler knows about them. We'll eventually do this better.
 */
const generatePagesResolver = async ({ INTERNAL_FUNCTIONS_SRC, FUNCTIONS_SRC = constants_1.DEFAULT_FUNCTIONS_SRC, PUBLISH_DIR, }) => {
    const functionsPath = INTERNAL_FUNCTIONS_SRC || FUNCTIONS_SRC;
    const jsSource = await (0, getPageResolver_1.getResolverForPages)(PUBLISH_DIR);
    await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsPath, constants_1.ODB_FUNCTION_NAME, 'pages.js'), jsSource);
    await (0, fs_extra_1.writeFile)((0, pathe_1.join)(functionsPath, constants_1.HANDLER_FUNCTION_NAME, 'pages.js'), jsSource);
};
exports.generatePagesResolver = generatePagesResolver;
// Move our next/image function into the correct functions directory
const setupImageFunction = async ({ constants: { INTERNAL_FUNCTIONS_SRC, FUNCTIONS_SRC = constants_1.DEFAULT_FUNCTIONS_SRC, IS_LOCAL }, imageconfig = {}, netlifyConfig, basePath, remotePatterns, responseHeaders, }) => {
    const imagePath = imageconfig.path || '/_next/image';
    if ((0, destr_1.default)(process.env.DISABLE_IPX)) {
        // If no image loader is specified, need to redirect to a 404 page since there's no
        // backing loader to serve local site images once deployed to Netlify
        if (!IS_LOCAL && imageconfig.loader === 'default') {
            netlifyConfig.redirects.push({
                from: `${imagePath}*`,
                query: { url: ':url', w: ':width', q: ':quality' },
                to: '/404.html',
                status: 404,
                force: true,
            });
        }
    }
    else {
        const functionsPath = INTERNAL_FUNCTIONS_SRC || FUNCTIONS_SRC;
        const functionName = `${constants_1.IMAGE_FUNCTION_NAME}.js`;
        const functionDirectory = (0, pathe_1.join)(functionsPath, constants_1.IMAGE_FUNCTION_NAME);
        await (0, fs_extra_1.ensureDir)(functionDirectory);
        await (0, fs_extra_1.writeJSON)((0, pathe_1.join)(functionDirectory, 'imageconfig.json'), {
            ...imageconfig,
            basePath: [basePath, constants_1.IMAGE_FUNCTION_NAME].join('/'),
            remotePatterns,
            responseHeaders,
        });
        await (0, fs_extra_1.copyFile)((0, pathe_1.join)(__dirname, '..', '..', 'lib', 'templates', 'ipx.js'), (0, pathe_1.join)(functionDirectory, functionName));
        (0, functionsMetaData_1.writeFunctionConfiguration)({
            functionName: constants_1.IMAGE_FUNCTION_NAME,
            functionTitle: constants_1.IMAGE_FUNCTION_TITLE,
            functionsDir: functionsPath,
        });
        // If we have edge functions then the request will have already been rewritten
        // so this won't match. This is matched if edge is disabled or unavailable.
        netlifyConfig.redirects.push({
            from: `${imagePath}*`,
            query: { url: ':url', w: ':width', q: ':quality' },
            to: `${basePath}/${constants_1.IMAGE_FUNCTION_NAME}/w_:width,q_:quality/:url`,
            status: 301,
        });
        netlifyConfig.redirects.push({
            from: `${basePath}/${constants_1.IMAGE_FUNCTION_NAME}/*`,
            to: `/.netlify/builders/${constants_1.IMAGE_FUNCTION_NAME}`,
            status: 200,
        });
    }
    if (basePath) {
        // next/image generates image static URLs that still point at the site root
        netlifyConfig.redirects.push({
            from: '/_next/static/image/*',
            to: '/static/image/:splat',
            status: 200,
        });
    }
};
exports.setupImageFunction = setupImageFunction;
/**
 * Look for API routes, and extract the config from the source file.
 */
const getApiRouteConfigs = async (publish, baseDir) => {
    const pages = await (0, fs_extra_1.readJSON)((0, pathe_1.join)(publish, 'server', 'pages-manifest.json'));
    const apiRoutes = Object.keys(pages).filter((page) => page.startsWith('/api/'));
    // two possible places
    // Ref: https://nextjs.org/docs/advanced-features/src-directory
    const pagesDir = (0, pathe_1.join)(baseDir, 'pages');
    const srcPagesDir = (0, pathe_1.join)(baseDir, 'src', 'pages');
    return await Promise.all(apiRoutes.map(async (apiRoute) => {
        const filePath = (0, files_1.getSourceFileForPage)(apiRoute, [pagesDir, srcPagesDir]);
        return { route: apiRoute, config: await (0, analysis_1.extractConfigFromFile)(filePath), compiled: pages[apiRoute] };
    }));
};
exports.getApiRouteConfigs = getApiRouteConfigs;
/**
 * Looks for extended API routes (background and scheduled functions) and extract the config from the source file.
 */
const getExtendedApiRouteConfigs = async (publish, baseDir) => {
    const settledApiRoutes = await (0, exports.getApiRouteConfigs)(publish, baseDir);
    // We only want to return the API routes that are background or scheduled functions
    return settledApiRoutes.filter((apiRoute) => apiRoute.config.type !== undefined);
};
exports.getExtendedApiRouteConfigs = getExtendedApiRouteConfigs;
/**
 * Warn the user of the caveats if they're using background or scheduled API routes
 */
const warnOnApiRoutes = async ({ FUNCTIONS_DIST, }) => {
    const functionsManifestPath = (0, pathe_1.join)(FUNCTIONS_DIST, 'manifest.json');
    if (!(0, fs_extra_1.existsSync)(functionsManifestPath)) {
        return;
    }
    const { functions } = await (0, fs_extra_1.readJSON)(functionsManifestPath);
    if (functions.some((func) => func.name.endsWith('-background'))) {
        console.warn((0, outdent_1.outdent) `
        ${chalk_1.default.yellowBright `Using background API routes`}
        If your account type does not support background functions, the deploy will fail.
        During local development, background API routes will run as regular API routes, but in production they will immediately return an empty "202 Accepted" response.
      `);
    }
    if (functions.some((func) => func.schedule)) {
        console.warn((0, outdent_1.outdent) `
        ${chalk_1.default.yellowBright `Using scheduled API routes`}
        These are run on a schedule when deployed to production.
        You can test them locally by loading them in your browser but this will not be available when deployed, and any returned value is ignored.
      `);
    }
};
exports.warnOnApiRoutes = warnOnApiRoutes;
