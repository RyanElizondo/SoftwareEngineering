"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiHandler = void 0;
// Aliasing like this means the editor may be able to syntax-highlight the string
const outdent_1 = require("outdent");
/* eslint-disable @typescript-eslint/no-var-requires */
const { Server } = require('http');
const path = require('path');
// eslint-disable-next-line n/prefer-global/url, n/prefer-global/url-search-params
const { URLSearchParams, URL } = require('url');
const { Bridge } = require('@vercel/node-bridge/bridge');
const { getMultiValueHeaders, getNextServer } = require('./handlerUtils');
// We return a function and then call `toString()` on it to serialise it as the launcher function
const makeHandler = (conf, app, pageRoot, page) => {
    var _a;
    // Change working directory into the site root, unless using Nx, which moves the
    // dist directory and handles this itself
    const dir = path.resolve(__dirname, app);
    if (pageRoot.startsWith(dir)) {
        process.chdir(dir);
    }
    // This is just so nft knows about the page entrypoints. It's not actually used
    try {
        // eslint-disable-next-line n/no-missing-require
        require.resolve('./pages.js');
    }
    catch { }
    // React assumes you want development mode if NODE_ENV is unset.
    ;
    (_a = process.env).NODE_ENV || (_a.NODE_ENV = 'production');
    // We don't want to write ISR files to disk in the lambda environment
    conf.experimental.isrFlushToDisk = false;
    // This is our flag that we use when patching the source
    // eslint-disable-next-line no-underscore-dangle
    process.env._BYPASS_SSG = 'true';
    for (const [key, value] of Object.entries(conf.env)) {
        process.env[key] = String(value);
    }
    // We memoize this because it can be shared between requests, but don't instantiate it until
    // the first request because we need the host and port.
    let bridge;
    const getBridge = (event) => {
        if (bridge) {
            return bridge;
        }
        // Scheduled functions don't have a URL, but we need to give one so Next knows the route to serve
        const url = event.rawUrl ? new URL(event.rawUrl) : new URL(path, process.env.URL || 'http://n');
        const port = Number.parseInt(url.port) || 80;
        const NextServer = getNextServer();
        const nextServer = new NextServer({
            conf,
            dir,
            customServer: false,
            hostname: url.hostname,
            port,
        });
        const requestHandler = nextServer.getRequestHandler();
        const server = new Server(async (req, res) => {
            try {
                await requestHandler(req, res);
            }
            catch (error) {
                console.error(error);
                throw new Error('Error handling request. See function logs for details.');
            }
        });
        bridge = new Bridge(server);
        bridge.listen();
        return bridge;
    };
    return async function handler(event, context) {
        // Ensure that paths are encoded - but don't double-encode them
        event.path = event.rawUrl ? new URL(event.rawUrl).pathname : page;
        // Next expects to be able to parse the query from the URL
        const query = new URLSearchParams(event.queryStringParameters).toString();
        event.path = query ? `${event.path}?${query}` : event.path;
        // We know the page
        event.headers['x-matched-path'] = page;
        const { headers, ...result } = await getBridge(event).launcher(event, context);
        // Convert all headers to multiValueHeaders
        const multiValueHeaders = getMultiValueHeaders(headers);
        multiValueHeaders['cache-control'] = ['public, max-age=0, must-revalidate'];
        console.log(`[${event.httpMethod}] ${event.path} (API)`);
        return {
            ...result,
            multiValueHeaders,
            isBase64Encoded: result.encoding === 'base64',
        };
    };
};
/**
 * Handlers for API routes are simpler than page routes, but they each have a separate one
 */
const getApiHandler = ({ page, config, publishDir = '../../../.next', appDir = '../../..', }) => 
// This is a string, but if you have the right editor plugin it should format as js
(0, outdent_1.outdent /* javascript */) `
  const { Server } = require("http");
  // We copy the file here rather than requiring from the node module
  const { Bridge } = require("./bridge");
  const { getMultiValueHeaders, getNextServer } = require('./handlerUtils')

  ${config.type === "experimental-scheduled" /* ApiRouteType.SCHEDULED */ ? `const { schedule } = require("@netlify/functions")` : ''}


  const { config }  = require("${publishDir}/required-server-files.json")
  let staticManifest
  const path = require("path");
  const pageRoot = path.resolve(path.join(__dirname, "${publishDir}", "server"));
  const handler = (${makeHandler.toString()})(config, "${appDir}", pageRoot, ${JSON.stringify(page)})
  exports.handler = ${config.type === "experimental-scheduled" /* ApiRouteType.SCHEDULED */ ? `schedule(${JSON.stringify(config.schedule)}, handler);` : 'handler'}
`;
exports.getApiHandler = getApiHandler;
